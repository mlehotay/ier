#!/usr/bin/env python3
"""
verify_order.py

Verify that a realized booklist ordering (authoritative selection projection)
does not violate hard prerequisite constraints derived from chapter YAML.

Inputs:
  --deps      build/dependencies.yml   (generated by scripts/generate_deps.py)
  --selection pub/IER-*-selection.md   (authoritative selection file; used for context/reporting)
  --booklist  build/*-input.txt        (the actual ordered list of chapter .md paths fed to Pandoc)

Hard failures (exit != 0):
  1) Missing hard prerequisites:
       If chapter B is in booklist and B hard-requires A, then A must also be in booklist.
  2) Order violations:
       If both A and B are in booklist and A must precede B, then pos[A] < pos[B].
  3) Unknown real chapter IDs:
       If the booklist contains an ID that looks like a canonical IER chapter (IER-*)
       but that ID is not present in deps, fail.

Notes:
  - This script does NOT reorder anything.
  - Structural and guardrail prerequisites are ignored for ordering constraints here,
    by design (per your clarified requirement).
  - Virtual/filler nodes (e.g., _break_ch_0001, _part_p01) are allowed in booklists
    and are ignored for dependency presence + ordering checks.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Any, Dict, List, Set, Tuple

try:
    import yaml  # PyYAML
except ImportError:
    print("ERROR: PyYAML is required (import yaml failed).", file=sys.stderr)
    raise


def _read_text(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return path.read_text(encoding="utf-8", errors="replace")


def _load_yaml(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"Deps YAML not found: {path}")
    data = yaml.safe_load(_read_text(path))
    if data is None:
        data = {}
    if not isinstance(data, dict):
        raise ValueError(f"Deps YAML must be a mapping: {path}")
    return data


def _read_booklist(booklist_path: Path) -> List[str]:
    """
    Read a booklist file (one .md path per line).
    Ignores blank lines and comments starting with '#'.
    """
    if not booklist_path.exists():
        raise FileNotFoundError(f"Booklist not found: {booklist_path}")

    lines = _read_text(booklist_path).splitlines()
    out: List[str] = []
    for line in lines:
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        out.append(s)
    return out


def _path_to_chapter_id(md_path: str) -> str:
    """
    Convert a markdown file path to chapter ID = filename stem.
    Example: 'pub/corpus-book/IER-dynamics.md' -> 'IER-dynamics'
    """
    p = Path(md_path)
    return p.stem


def _is_virtual_id(chapter_id: str) -> bool:
    """
    Convention: filler/layout/pseudo nodes start with underscore.
    These are allowed in booklists and are outside deps/manifest.
    """
    return chapter_id.startswith("_")


def _is_real_chapter_id(chapter_id: str) -> bool:
    """
    Convention: canonical chapters are IER-*.
    These must exist in deps to be eligible for constraint checks.
    """
    return chapter_id.startswith("IER-")


def _collect_constraints(deps: Dict[str, Any]) -> Tuple[Dict[str, List[str]], Set[str], List[str]]:
    """
    Return:
      hard_requires: dict chapter_id -> list prereq_ids
      known_chapters: set of chapter_ids present in deps
      warnings: list[str]
    """
    warnings: List[str] = []

    chapters = deps.get("chapters", {})
    if not isinstance(chapters, dict):
        raise ValueError("deps['chapters'] must be a mapping")

    known = set(chapters.keys())

    hard_requires: Dict[str, List[str]] = {}
    for cid, cdata in chapters.items():
        if not isinstance(cdata, dict):
            continue
        reqs = cdata.get("requires", {})
        if not isinstance(reqs, dict):
            reqs = {}
        hard = reqs.get("hard", [])
        if hard is None:
            hard = []
        if isinstance(hard, list):
            hard_list = [x.strip() for x in hard if isinstance(x, str) and x.strip()]
        elif isinstance(hard, str):
            hard_list = [hard.strip()] if hard.strip() else []
        else:
            hard_list = []

        # Ensure determinism
        hard_requires[cid] = sorted(set(hard_list))

    # Optionally cross-check hard_edges if present
    hard_edges = deps.get("hard_edges", None)
    if hard_edges is not None and not isinstance(hard_edges, list):
        warnings.append("deps['hard_edges'] present but not a list; ignored.")

    return hard_requires, known, warnings


def _format_violation_context(
    constrained_ids: List[str],
    pos: Dict[str, int],
    a: str,
    b: str,
) -> str:
    ia = pos.get(a, -1)
    ib = pos.get(b, -1)
    around: List[str] = []
    if 0 <= ib < len(constrained_ids):
        start = max(0, ib - 3)
        end = min(len(constrained_ids), ib + 4)
        snippet = []
        for i in range(start, end):
            mark = "->" if i == ib else "  "
            snippet.append(f"{mark} [{i+1}] {constrained_ids[i]}")
        around = snippet
    ctx = ""
    if around:
        ctx = "\nContext around dependent (constrained list):\n" + "\n".join(around)
    return f"(positions: {a}={ia+1 if ia>=0 else '—'}, {b}={ib+1 if ib>=0 else '—'}){ctx}"


def verify(
    *,
    deps_path: Path,
    selection_path: Path,
    booklist_path: Path,
) -> int:
    deps = _load_yaml(deps_path)
    hard_requires, known_chapters, warnings = _collect_constraints(deps)

    booklist_paths = _read_booklist(booklist_path)
    if not booklist_paths:
        print(f"ERROR: empty booklist: {booklist_path}", file=sys.stderr)
        return 2

    booklist_ids_all = [_path_to_chapter_id(p) for p in booklist_paths]

    # Partition IDs
    virtual_ids = [cid for cid in booklist_ids_all if _is_virtual_id(cid)]
    non_virtual_ids = [cid for cid in booklist_ids_all if not _is_virtual_id(cid)]

    # Detect duplicates among non-virtual IDs (virtual fillers may be repeated)
    seen: Set[str] = set()
    dups: List[str] = []
    for cid in non_virtual_ids:
        if cid in seen:
            dups.append(cid)
        seen.add(cid)
    if dups:
        dups_sorted = sorted(set(dups))
        print("ERROR: duplicate chapter IDs in booklist:", file=sys.stderr)
        for d in dups_sorted:
            print(f"  - {d}", file=sys.stderr)
        print(f"Booklist: {booklist_path}", file=sys.stderr)
        print(f"Selection: {selection_path}", file=sys.stderr)
        return 2

    # Unknown check: only complain about IDs that look like canonical chapters (IER-*)
    unknown_real = sorted(
        [
            cid
            for cid in non_virtual_ids
            if _is_real_chapter_id(cid) and cid not in known_chapters
        ]
    )
    if unknown_real:
        print("ERROR: booklist contains chapter IDs not present in deps/manifest:", file=sys.stderr)
        for cid in unknown_real:
            print(f"  - {cid}", file=sys.stderr)
        if virtual_ids:
            print("NOTE: virtual/filler IDs were present but ignored (start with '_').", file=sys.stderr)
        print(f"Deps: {deps_path}", file=sys.stderr)
        print(f"Booklist: {booklist_path}", file=sys.stderr)
        print(f"Selection: {selection_path}", file=sys.stderr)
        return 2

    # Constrain dependency verification to chapters known to deps.
    # (This automatically ignores virtual fillers and any other non-deps nodes.)
    constrained_ids = [cid for cid in non_virtual_ids if cid in known_chapters]

    if not constrained_ids:
        # If your entire booklist is virtual, that's likely a build configuration bug.
        print("ERROR: no deps-known chapters found in booklist (only virtual or unknown nodes).", file=sys.stderr)
        print(f"Deps: {deps_path}", file=sys.stderr)
        print(f"Booklist: {booklist_path}", file=sys.stderr)
        print(f"Selection: {selection_path}", file=sys.stderr)
        return 2

    # Build position map (0-based) over constrained_ids only
    pos = {cid: i for i, cid in enumerate(constrained_ids)}
    in_book = set(constrained_ids)

    # Check missing hard prerequisites (FAIL)
    missing_pairs: List[Tuple[str, str]] = []  # (dependent, missing_prereq)
    for b in constrained_ids:
        for a in hard_requires.get(b, []):
            if a not in in_book:
                missing_pairs.append((b, a))

    if missing_pairs:
        print("ORDER VERIFICATION FAILED", file=sys.stderr)
        print("ERROR: missing hard prerequisites (selection must include all hard prereqs):", file=sys.stderr)
        for b, a in sorted(missing_pairs, key=lambda t: (t[0], t[1])):
            print(f"  - {b} requires {a}, but {a} is not in the booklist.", file=sys.stderr)
        print(f"Selection: {selection_path}", file=sys.stderr)
        print(f"Booklist:  {booklist_path}", file=sys.stderr)
        return 1

    # Check ordering violations (FAIL)
    violations: List[Tuple[str, str]] = []  # (prereq, dependent)
    for b in constrained_ids:
        for a in hard_requires.get(b, []):
            # both present guaranteed now
            if pos[a] > pos[b]:
                violations.append((a, b))

    if violations:
        print("ORDER VERIFICATION FAILED", file=sys.stderr)
        print("ERROR: hard prerequisite order violations:", file=sys.stderr)
        for a, b in sorted(violations, key=lambda t: (t[1], t[0])):
            ctx = _format_violation_context(constrained_ids, pos, a, b)
            print(f"  - {a} must precede {b} {ctx}", file=sys.stderr)
        print(f"Selection: {selection_path}", file=sys.stderr)
        print(f"Booklist:  {booklist_path}", file=sys.stderr)
        return 1

    # Success (print warnings if any)
    if warnings:
        for w in warnings:
            print(f"WARNING: {w}", file=sys.stderr)

    if virtual_ids:
        print(
            f"NOTE: ignored {len(virtual_ids)} virtual/filler nodes in booklist "
            f"(IDs start with '_').",
            file=sys.stderr,
        )

    print(
        f"OK: order verified for selection '{selection_path.name}' "
        f"against deps '{deps_path.name}' using booklist '{booklist_path.name}'."
    )
    return 0


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--deps", required=True, help="Path to generated deps YAML (e.g., build/dependencies.yml)")
    ap.add_argument("--selection", required=True, help="Path to selection file (for context/reporting)")
    ap.add_argument("--booklist", required=True, help="Path to realized booklist (ordered .md paths)")
    args = ap.parse_args()

    deps_path = Path(args.deps)
    selection_path = Path(args.selection)
    booklist_path = Path(args.booklist)

    # selection file is only used for context, but ensure it exists to avoid confusion
    if not selection_path.exists():
        print(f"ERROR: selection file not found: {selection_path}", file=sys.stderr)
        return 2

    try:
        return verify(
            deps_path=deps_path,
            selection_path=selection_path,
            booklist_path=booklist_path,
        )
    except (FileNotFoundError, ValueError) as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
