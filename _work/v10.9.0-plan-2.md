# v10.9.0-plan-2.md

---

## 0. Ground rules we will enforce

* **No non-deterministic fields** in generated artifacts (no timestamps, hostnames, absolute paths in hashes, etc.).
* All ordering in outputs is **stable** (sorted keys where applicable, sorted lists where semantics permit).
* Generator outputs are reproducible **byte-for-byte** given identical inputs.

---

## 1. `generate_deps.py` upgrades

### 1.1 Generator identity + version (A1)

**Decision:** hardcode semantic version.

**Implement**

* Add in `generate_deps.py`:

  * `__version__ = "X.Y.Z"`
* Emit into both outputs:

In `build/dependencies.yml`:

```yaml
meta:
  generator:
    name: generate_deps.py
    version: X.Y.Z
```

In `IER-prerequisites.md` “Generation Metadata”:

* Generator: `generate_deps.py@X.Y.Z`

**Notes**

* Version should be bumped for schema changes or dependency interpretation changes.

---

### 1.2 Manifest hash (A2)

**Decision:** compute **SHA-256 of manifest bytes** (exact file contents), and record path.

**Implement**

* Read manifest file as bytes.
* Compute `sha256`.
* Emit:

```yaml
meta:
  manifest:
    path: <path used>
    sha256: <hex>
```

Also include in the markdown metadata block.

---

### 1.3 Deterministic build hash (A3)

**Decision:** implement and always emit an **inputs-only build hash** distinct from git hash.

**Define build hash inputs**

1. Manifest file bytes
2. Bundles file bytes (if bundles are used; otherwise include empty marker)
3. Normalized extracted dependency metadata from chapters (see normalization below)

**Normalization rules**

* Convert extracted records into a canonical JSON object:

  * sorted keys
  * stable list ordering:

    * where lists are sets (e.g., `hard`, `soft`, `gates.opens/requires`, guardrails), sort lexicographically
    * where list order is meaningful (rare), preserve and document
* Serialize with:

  * UTF-8
  * no whitespace variability (e.g., `separators=(",", ":")`)
* Hash the concatenation:

  * `b"MANIFEST\0" + manifest_bytes + b"\0BUNDLES\0" + bundles_bytes + b"\0META\0" + normalized_json_bytes`

**Emit**

```yaml
meta:
  build_hash:
    sha256: <hex>
```

---

### 1.4 Gates “required_by” index (A4)

**Decision:** gates *requirements* exist and are declared as `ier.gates.requires`.

**Implement**

* Accept chapter front matter:

  * `ier.gates.opens: [...]`
  * `ier.gates.requires: [...]`
* Validate identifiers with a strict pattern, e.g.:

  * `^[a-z0-9][a-z0-9_.-]*$`
* Populate gate index:

```yaml
gate_index:
  <gate_id>:
    opened_by: [chapter_ids...]
    required_by: [chapter_ids...]
```

**Also emit in markdown**

* Gate Index section includes both lists.

---

### 1.5 Structured warning taxonomy (A5)

**Decision:** warnings become structured objects (with stable codes), while markdown remains readable.

**Implement data model**
In YAML:

```yaml
warnings:
  - code: W001
    kind: YAML_MISSING_IER_BLOCK
    chapter: IER-foo
    message: "Missing 'ier' YAML block; treated as empty metadata."
```

**Initial warning codes (minimum viable set)**

* `W001 YAML_MISSING_IER_BLOCK`
* `W002 YAML_SCHEMA_MISSING_KEY`
* `W003 YAML_PARSE_ERROR`
* `W004 UNKNOWN_IDENTIFIER`
* `W005 UNKNOWN_BUNDLE`
* `W006 DUPLICATE_IDENTIFIER_IN_LIST`
* `W007 NON_CANONICAL_ID_FORMAT` (if you enforce format)
* (Optional) `W008 VIRTUAL_NODE_IGNORED` (if generator observes them)

**Markdown presentation**

* Group by code, then list chapters + messages (stable ordering).

---

### 1.6 Keep the existing git hash (if already present)

**Decision:** keep git commit hash as an *extra* provenance field, but never rely on it for determinism.

**Emit**

```yaml
meta:
  git:
    commit: <hash or null>
```

---

## 2. `verify_order.py` upgrades

### 2.1 Optional enforcement modes for non-hard prereqs (C1, C2)

**Decision:** add flags, default OFF (current behavior preserved).

**Implement CLI flags**

* `--enforce-structural-order`
* `--enforce-guardrail-order`

**Behavior**

* Default: only hard prerequisites contribute to ordering validity.
* If flag enabled:

  * treat structural / guardrail prereqs as ordering constraints
  * fail on violations with clear diagnostics

---

### 2.2 Machine-readable reporting of ignored virtual/filler nodes (C3)

**Decision:** emit a small artifact for CI diagnostics.

**Implement**

* Add output file (recommended):

  * `build/verify_order.report.yml` (or `.json`)
* Include:

```yaml
ignored:
  virtual_nodes:
    count: N
    ids: [ ...stable-sorted... ]
```

This replaces “stderr-only” as the sole record.

---

## 3. Cross-cutting tooling hardening

### 3.1 Determinism enforcement test (D1)

**Decision:** implement as CI / Make target rather than a runtime mode.

**Implement**

* Add `make determinism` (or CI step) that:

  1. runs `generate_deps.py` twice into separate temp dirs (or uses distinct build prefixes)
  2. byte-compares `build/dependencies.yml` and `IER-prerequisites.md`
  3. fails if any difference

**Important**

* Ensure generator writes YAML deterministically:

  * stable key ordering
  * stable list ordering
  * fixed line wrapping choices (or disable wrapping)

---

### 3.2 Formal schema for `build/dependencies.yml` (D2)

**Decision:** create a JSON Schema and validate in CI.

**Implement**

* Add `assets/dependencies.schema.json`
* Add `meta.schema` fields to generated YAML:

```yaml
meta:
  schema:
    name: IER-dependencies
    version: 1.0.0
```

* CI step:

  * load YAML → JSON object
  * validate against schema

---

### 3.3 Compatibility contract between generator and verifier (D3)

**Decision:** version-gate verifier against deps schema major version.

**Implement**

* `verify_order.py` reads `meta.schema.version`
* Rules:

  * if major version unsupported → fail with actionable message
  * if minor higher → warn (or allow) depending on policy

---

## 4. Explicit non-goals (tracked, but not implemented now)

These remain on the roadmap but are not part of this implementation batch:

* Guardrail propagation / closure logic
* Bridge semantics / tier-crossing enforcement
* Gate discipline enforcement (“must open before use”) — can be added later behind `--strict-gates`

(You can still keep indexing and audit surfaces now; enforcement later.)

---

## 5. Recommended execution order (minimize churn)

1. **Meta + hashes**: A1, A2, A3
2. **Gates required_by**: A4
3. **Structured warnings**: A5
4. **Verifier outputs + flags**: C3, C1/C2
5. **Determinism CI**: D1
6. **Schema + compatibility**: D2, D3

---
