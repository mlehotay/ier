## 0) Interface and Inputs

### Invocation (match Makefile)

```bash
python3 scripts/verify_book.py <selection.md> <booklist.txt> [flags]
```

### Inputs used

* `selection.md`: the source of truth for intended chapter stream + part/section markers
* `booklist.txt`: the emitted Pandoc input list produced by `extract_book_list.py`
* The files referenced by `booklist.txt` (including `build/_*.md` generated ones)

### Outputs

* Non-zero exit on any error
* Errors printed as: `ERROR: <path>:<line>: <rule>: <message>`
* Optional: a summarized error count by category at end

---

## 1) Booklist Integrity Checks (cheap, always-on)

These are “sanity checks” on `booklist.txt` itself:

1. **Non-empty list** (already guarded in Makefile, but verify should enforce too)
2. **No blank lines**, no whitespace-only entries
3. **No duplicate paths** (should already be deduped; duplicates = a bug or list corruption)
4. **All paths exist** (repo-relative file existence; absolute paths allowed but still must exist)
5. **All entries end with `.md`** (Pandoc list should be only markdown inputs)

Optional: warn (not error) if paths contain spaces (can be annoying in shell/Pandoc).

---

## 2) Recompute the Expected Emitted List (authoritative build equivalence)

This is the “core correctness” check: verify should be able to say:

> “Given `selection.md`, the expected stream of (dividers + breaks + chapters), and given the scaffold directory, the emitted list should equal the booklist.”

There are two ways to do this:

### Preferred (strongest): import the build logic

* Refactor `extract_book_list.py` so its core functions are importable (no behavior change):

  * `collect_scaffold_files()`
  * `extract_stream_and_dividers()`
  * `build_emit_list()`
* Then `verify_book.py` imports these and recomputes `expected_emitted`.
* Compare `expected_emitted` to `actual_emitted` from `booklist.txt`.

This is the best path because it ensures **verify is checking the real algorithm** and won’t drift.

### If you don’t want imports:

* Re-implement the same logic in verify (higher drift risk). I recommend the import approach.

**Checks here:**

* **Exact list equality**: same length, same order, exact paths
* If mismatch:

  * print a compact diff (first differing index + surrounding context)
  * optionally emit a “numbered” comparison report

---

## 3) Build-Mechanics Invariants (derived from your current build rules)

Even if the list equality passes, it’s useful to explicitly enforce the *intent* invariants:

### 3.1 Generated structural files naming + content checks

**A) Part dividers:**

* Path must match: `build/_part_pPP.md`
* Contents must:

  * include `\cleardoublepage` (typically as the first non-empty line)
  * contain exactly one H1 `# ...` (Part title line)
* Enforce: **no part divider for Part 0**

**B) Section dividers:**

* Path must match: `build/_section_pPP_sSS.md`
* Contents must:

  * include `\clearpage` (first non-empty line)
  * contain exactly one H2 `## ...` (Section title line)

**C) Chapter breaks:**

* Path must match: `build/_break_ch_NNNN.md`
* Contents must:

  * be minimal and contain `\clearpage`
  * no headings required

### 3.2 Placement invariants in the emitted list

**A) Chapter breaks precede every chapter path**

* For every chapter entry (any non-generated `.md` coming from selection paths), verify the immediately preceding entry is a `_break_ch_*.md`.

**B) Section divider insertion rule**

* A section divider appears only immediately before a chapter (after any number of other pending dividers is possible, but in your implementation they are emitted when the next chapter arrives).
* Verify section dividers are never “stranded” at the end of a part with no following chapter.

**C) Part divider insertion policy**

* For each Part `p>=1`, if there are **no scaffold files** in slots `p0–p5` included for that part, then a part divider `_part_pPP.md` must appear in the emitted list before that part’s stream.
* If there *are* before-scaffolds, then the autogenerated part divider must **not** appear (to avoid fighting authored part headers).
* This requires knowing scaffold slot → part mapping (NN//10, NN%10) and which scaffolds are “before”.

This checks the stated policy, not just “it happens to match”.

---

## 4) Scaffold Directory Compliance Checks (build input hygiene)

Verify should validate the scaffold directory implied by the selection/booklist context.

### 4.1 Determine scaffold directory

Since Makefile calls verify only for corpus right now, you can do:

* either: infer scaffold dir from selection name (`IER-corpus-selection.md` → `pub/corpus-book`, `IER-tldr-selection.md` → `pub/tldr-book`)
* or: require explicit flag `--scaffold-dir pub/corpus-book` (most robust)
* or: parse it out by scanning the emitted list for `pub/corpus-book/*.md` entries

### 4.2 Enforce scaffold naming rule

* Every scaffold file included must be named `NN-description.md`
* Validate numeric prefix is 00–99
* Validate it lives in the expected scaffold directory (warn if not)

### 4.3 Enforce scaffold slot discipline (structural)

* Compute `(part_index, slot)` for each scaffold
* Verify:

  * slot 0–5 scaffolds appear before any content stream for that part
  * slot 6–9 scaffolds appear after content stream for that part
* Since the emitted list is flattened, you’ll need to find the boundaries of each part stream using either:

  * part dividers / authored part header scaffolds (preferred), or
  * recomputed `expected_emitted` segmented by part (best if using imported build logic)

---

## 5) Canon Authoring Rules (A1–A11) — scoped, not naive

This is where old `verify_book.py` usually goes wrong: you *must* apply different checks to:

1. **Canonical corpus chapters**: `IER/IER-*.md`
2. **Scaffold files**: `pub/corpus-book/*.md`, `pub/tldr-book/*.md`
3. **Generated structural files**: `build/_*.md`

### 5.1 Canonical chapters (`IER/IER-*.md`): strict A1–A11

Minimum enforceable set (high value, low false positives):

* **A1**: exactly one H1 and it is the **first non-empty line**
* **A2**: heading levels don’t skip (outside code fences)
* **A3**: YAML front matter forbidden (`---` as initial front matter block)
* **A4**: ban raw LaTeX document/preamble/layout directives (documentclass, usepackage, geometry, pagestyle, etc.)
* **A5**: no indent-based code blocks (outside fences)
* **A7**: no HTML tables (`<table`)
* **A8**: no bare URLs in prose (configurable: error vs warn)
* **A9**: forbid unstable whitespace characters (NBSP, zero-width, etc.)
* **Math/Unicode discipline**: keep your glyph checks (unicode operators/arrows/etc.), and “math-like glyphs inside backticks/code fences”

Optional but useful:

* enforce “no H1 besides the first” (part of A1)
* ensure code fences are balanced (odd count → error)

### 5.2 Scaffold files: partially strict, but allow what scaffolds need

Scaffolds are publication-layer, non-theory. They may legitimately include pagebreak raw LaTeX.

So:

* Still enforce **A5/A7/A9** (these are rendering stability rules)
* Enforce **A3** (no YAML)
* Allow raw LaTeX page breaks (`\clearpage`, `\cleardoublepage`) and perhaps ToC directives if you use them
* For headings:

  * Do **not** require A1 (some scaffolds might be intentionally minimal)
  * But do enforce “no heading skips” if headings are present (A2), as a stability check

### 5.3 Generated build files (`build/_*.md`): validate *only* the expected structure

Do not apply A1/A2 blanket rules, because generated files intentionally differ:

* part divider uses `#` but is generated; it’s fine if it begins with `\cleardoublepage`
* section divider uses `##`
* break pages may have no headings

So for generated files: only enforce the content contracts in §3.1.

---

## 6) Selection File Compliance Checks (authoring hygiene for selection docs)

Selection files are non-authoritative but still need to be well-formed.

Checks that matter:

* Every backticked `.md` token normalizes to an existing file path
* `##` and `###` markers are recognized; ensure no heading skips **within selection itself** (optional)
* Warn (not error) if selection contains `####` or deeper headings (ignored by build, but often indicates a mistake)

Also: verify that selection does not contain YAML front matter (consistent with corpus discipline).

---

## 7) CLI Flags (keep it usable)

Suggested flags:

* `--skip-glyphs`
* `--skip-authoring`
* `--skip-structure` (only do authoring checks)
* `--scope {canonical,all}` for authoring checks (default: canonical)
* `--allow-bare-urls` or `--bare-urls {error,warn,ignore}`
* `--scaffold-dir <dir>` (optional but recommended)
* `--explain` (print computed part/section/chapter counts and paths summary; no errors unless requested)

---

## 8) Reporting Format and Ergonomics

When a list mismatch happens, don’t dump 400 lines. Do:

* Print:

  * first mismatch index
  * expected vs actual at that index
  * ±3 lines of context
* If `--diff-full`, write:

  * `build/<book>-verify.expected.numbered.txt`
  * `build/<book>-verify.actual.numbered.txt`

For content errors:

* Always print `file:line` with the rule identifier (`A1`, `A2`, `BUILD-SECTION`, etc.)

---

## 9) What verify should NOT do

* It should **not** interpret theory.
* It should **not** enforce publishing aesthetic preferences.
* It should **not** assume manifest structure for the books anymore (selection drives book assembly now).
* It should **not** apply corpus authoring rules to generated structural pages in a way that creates false failures.

---

## Bottom line

A correct updated `verify_book.py` will have **three independent layers**:

1. **Pipeline equivalence**: “booklist equals what build would generate from selection + scaffold”
2. **Build invariants**: structural files exist, are well-formed, and are placed correctly
3. **Canon authoring discipline**: strict checks on `IER/IER-*.md`, scoped checks on scaffolds, contract checks on generated `_*.md`
